# SOLID

1. 단일 책임 원칙(SRP: Single-Responsibility Principle)
    - 한 타입은 단 한가지의 책임만을 가져야한다.
        
        책임은 변경의 이유야.
        
    - 우리는 높은 응집도로 낮은 결합도를 갖게 해야한다.
    - 여러 객체 책임질 때 문제
        
        목적이 같고 코드가 중복되는가? 아니면 코드가 우연히 중복되는가?
        
        야구 게임의 스코어 변경이 농구 게임에 영향을 줄 수 있음! 스코어 계산기의 변경 이유는 여러 개
        
2. 개방-폐쇄 원칙(OCP: Open-Close-Principle)
    
    확장에 열려있고 변경에 닫혀있다.
    
    == 기능을 추가할수는 있어도 기존의 기능을 수정하지 않도록 하자.
    
    (Enum vs Protocol) → Enum은 규칙 위반이지만 Protocol은 원칙에 합당하다.
    
    🤔  그런데 프로토콜은 항상 OCP를 충족시켜줄 수 있을까??
    
    결국.. 정답은 없다… 어떤 방향으로 나아갈 지 모를 수 있지만 예측이 된다면 최대한 지키면서 가야한다.
    
3. 리스코프 치환 원칙(LSP: Liskov Substitution Principle)
    
    자식 클래스는 부모 클래스로써의 역할을 완벽히 할 수 있어야한다.
    
    자신의 속성을 위해 부모 클래스 기능을 거부 / 퇴화
    
4. 의존성 역전 원칙(DIP: Dependency Inversion Principle)
    - 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. → 구체적인 것은 잘 변한다.
    - 구체적인 사항은 추상화에 의존해야한다. → 추상적인건 잘 안변한다.
    - delegate가 가장 대표적인 예
5. 인터페이스 분리 법칙(ISP: Interface Segregation Principle)
    - 클라이언트가 불필요한 자신이 사용하지 않는 인터페이스에 의존하지 말아야한다.
    - 상속받은 메서드를 퇴화시켜야하는 경우가 발생할 수 있음
    - 불필요한 인터페이스에 의존하여 불필요한 빌드가 유발될 수 있음
    - 큰 인터페이스를 작은 인터페이스들로 분리하고,
    필요한 부분만 클라이언트가 취사선택하여 사용할 수 있게 해야함.