# ARC
참조 타입은 하나의 인스턴스가 참조를 통해 여러 곳에서 접근하기 때문에 언제 메모리에서 해제되는지가 중요한 문제이다.     
해제되지 않으면 한정적인 메모리 자원을 낭비하게 되며, 이는 성능의 저하로 이어지게 됩니다.   

> ARC와 Value Type
> ARC가 관리해주는 참조 횟수 계산(Reference Counting)은 참조 타입인 클래스의 인스턴스에만 적용됩니다.   
> 구조체나 열거형은 다른 곳에서 참조하지 않기 때문에 ARC로 관리할 필요가 없습니다.

## 🟢 ARC란?
ARC기능은 이름에서 알 수 있듯이 자동으로 메모리를 관리해주는 방식입니다.    
ARC는 더이상 필요하지 않은 클래스의 인스턴스를 메모리에서 해제하는 방식으로 동작합니다.     

자바 등 다른 프로그래밍 언어에서 사용되는 메모리 관리 기법인 가비지 컬렉션(Garbage Collection) 기법과 어떤 차이가 있을까요?
ARC와 Garbage Collection의 가장 큰 차이는 `참조를 계산하는 시점`입니다.

|메모리 관리 기법|ARC|Garbage Collection|
|:---:|:---|:---|
|참조 카운팅 시점|컴파일 시|프로그램 동작 중|
|장점|1. 컴파일 당시 이미 인스턴스의 해제 시점이 정해져 있어서 **인스턴스가 언제 메모리에서 해제될 지 예측할 수 있다.** <br/>2. 컴파일 당시 이미 인스턴스의 해제 시점이 정해져 있어서 **메모리 관리를 위한 시스템 자원을 추가할 필요가 없습니다.**|1.상호 참조 상황등의 복잡한 상황에서도 인스턴스를 해제할 수 있는 가능성이 더 높습니다. <br/>2.특별히 규칙에 신경 쓸 필요가 없습니다.|
|단점|**ARC의 작동 규칙을 모르고 사용하면 인스턴스가 메모리에서 영원히 해제되지 않을 가능성이 있습니다.**ㄴ|1. 프로그램 동작 외에 메모리 감시를 위한 추가 자원이 필요하므로 한정적인 자원 환경에서는 성능 저하가 발생할 수 있습니다. <br/>2. 명확한 규칙이 없기 때문에 인스턴스가 정확히 언제 메모리에서 해제될 지 예측하기 어렵습니다.|

> 💡 우리가 ARC를 이용해 자동으로 메모리 관리를 받기 위해서는 몇 가지 규칙을 알아야 합니다.
> 클래스의 인스턴스를 생성할 때마다 ARC는 그 인스턴스에 대한 정보를 저장하기 위한 메모리 공간을 따로 또 할당합니다.    
그 메모리 공간에서 인스턴스의 타입 정보와 함께 그 인스턴스와 관련된 저장 프로퍼티의 값 등을 저장합니다.     
그 후에 인스턴스가 더 이상 필요 없는 상태가 되면 인스턴스가 차지하던 메모리 공간을 다른 용도로 활용할 수 있도록 ARC가 메모리에서 인스턴스를 없앱니다.

## 🔴 강한참조 Strong
**인스턴스가 계속해서 메모리에 남아있어야 하는 명분을 만들어 주는 것이 바로 강한참조(Strong Reference)입니다.**   

인스턴스는 참조 횟수가 `0이 되는 순간` 메모리에서 해제되는데, 인스턴스를 다른 인스턴스의 프로퍼티나 변수, 상수 등에 할당할 때     
강한참조를 사용하면 참조 횟수가 `1증가`합니다.   
또 강한참조를 사용하는 프로퍼티, 변수, 상수 등에 nil을 할당해주면 원래 자신에게 할당되어 있던 인스턴스의 참조 횟수가 `1감소`합니다.

`참조의 기본은 강한 참조`이므로 클래스 타입의 프로퍼티, 변수, 상수 등을 선언할 때 별도의 식별자를 명시하지 않으면 강한참조를 합니다.

### 🟢 강한참조 순환문제
인스턴스끼리 서로가 서로를 강한참조할 때를 대표적인 강한참조 순환(Strong Reference Cycle)이라고 합니다. 

## 🔥 클로저의 강한참조 순환
클로저가 인스턴스의 프로퍼티일 때나, 클로저의 값 획득 특성 때문에 발생합니다.   
강한참조 순환이 발생하는 이유는 **`클로저가 클래스와 같은 참조 타입이기 때문`** 입니다.     
클로저를 클래스 인스턴스의 프로퍼티로 할당하면 클로저의 참조가 할당됩니다.      
이때 참조 타입과 참조 타입이 서로 강한참조를 하기 때문에 강한참조 순환 문제가 발생합니다.   
이러한 클로저의 강한참조 순환 문제를 **`클로저의 획득 목록을 통해 해결`** 할 수 있습니다.   

### 💡 획득목록
`획득목록(Capture list)`을 통해 해결할 수 있다고 하였습니다.  
**`획득목록은 클로저 내부에서 참조 타입을 획득하는 규칙을 제시해줄 수 있는 기능입니다.`**   

획득목록은 클로저 내부의 매개변수 목록 이전 위치에 작성해줍니다.    
**획득목록은 참조 방식과 참조할 대상을 `대괄호([])`로 둘러싼 목록 형식으로 작성하며 획득목록 뒤에는 `in 키워드`를 써줍니다.**   
획득목록에 명시한 요소가 참조 타입이 아니라면 해당 요소들은 클로저가 생성될 떄 초기화됩니다.    

참조타입은 획득목록에서 어떤 방식으로 참조할 것인지, 즉 `강한획득(Strong Capture)`을 할 것인지, `약한획득(Weak Capture)`을 할 것인지, `미소유획득(Unowned Capture)`을 할 것인지를 정해줄 수 있습니다.     
또 획득의 종류에 따라 참조 횟수를 증가시킬지 결정할 수 있습니다.    
**`명심해야할 것은 약한획득을 하게 되면 획득목록에서 획득하는 상수가 옵셔널 상수로 지정된다는 것입니다.`**    
그 이유는 차후에 클로저 내부에서 약한획득한 상수를 사용하려고 할 때 이미 메모리에서 해제된 상태일 수 있기 때문입니다.   
약한획득은 기본적으로 타입을 옵셔널으로 사용하는 것입니다.

```Swift
// 획득목록의 약한참조를 통한 차후 접근 문제 방지
class Person {
    let name: String
    let hobby: String?

    lazy var introduce: () -> String = { [weak self] in
        // 'self'를 사용하는 이유는 예약어를 참고합니다.
        guard let 'self' = self else {
            return "원래의 참조 인스턴스가 없어졌습니다."
        }

        var introduction: String = "My name is \(self.name)."

        guard let hobby = self.hobby else {
            return introduction
        }

        introduction += " "
        introduction += "My hobby is \(hobby)."
        
        return introduction
    }

    init(name: String, hobby: String? = nil) {
        self.name = name
        self.hobby = hobby
    }

    deinit {
        print("\(name) is being deinitialized")
    }
}

var jason: Person? = Person(name: "Jason", hobby: "eating")
var jasonFriend: Person? = Person(name: "Jason Friend", hobby: "playing game")
```

## 🔥 약한참조 Weak
약한참조(Weak Reference)는 강한참조와 달리 자신이 참조하는 인스턴스의 참조 횟수를 증가시키지 않습니다.  
참조 타입의 프로퍼티나 변수의 선언 앞에 weak 키워드를 써주면 약한참조합니다.
약한참조를 사용한다면 자신이 참조하는 인스턴스가 메모리에서 해제될 수도 있다는 것을 예상해볼 수 있어야합니다.
자신이 참조 횟수를 증가시키지 않았기 때문에 그 인스턴스를 강한참조하던 프로퍼티나 변수에서 참조 횟수를 감소시켜 0으로 만들면    
자신이 참조하던 인스턴스가 메모리에서 해제되기 때문입니다.

> 약한참조는 상수에서 쓰일 수 없습니다.     
> 만약 자신이 참조하던 인스턴스가 메모리에서 해제된다면 `nil`이 할당될 수 있어야 하기 때문입니다.   
> 하여 자신의 값을 변경할 수 있는 변수로 선언해야합니다.    
> 더불어 nil이 할당될 수 있도록 약한참조는 항상 옵셔널이어야 합니다.

인스턴스가 메모리에서 해제될 때, 자신의 프로퍼티가 강한참조를 하던 인스턴스의 참조 횟수를 1감소시킨다는 것을 알 수 있습니다.
자신이 참조하는 **`인스턴스가 메모리에서 해제되면 자동으로 nil을 할당`** 한다는 것을 알 수 있습니다.

## 🟢 미소유참조 Unowned
미소유참조(Unowned Reference)는 weak와 동일하게 인스턴스의 참조 횟수를 증가시키지 않습니다.     
하지만 미소유참조는 **약한참조와 다르게 자신이 참조하는 인스턴스가 항상 메모리에 존재할 것이라는 전제를 기반으로 동작**합니다.  
즉, **`자신이 참조하는 인스턴스가 메모리에서 해제되더라도 스스로 nil을 할당해주지 않는다는 뜻`** 입니다.        
그렇기 때문에 미소유참조는 변수나 프로퍼티는 옵셔널이나 변수가 아니어도 됩니다.

따라서 **미소유참조는 참조하는 동안 해당 인스턴스가 메모리에서 해제되지 않으리라는 확신이 있을때만 사용합니다.**
참조 타입의 변수나 프로퍼티의 정의 앞에 `unowned` 키워드를 써주면 그 변수(상수)나 프로퍼티는 자신이 참조하는 인스턴스를 미소유참조하게 됩니다.


### 🌐 Reference Site
[Automatic Reference Counting | Swift Documents](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/#Resolving-Strong-Reference-Cycles-Between-Class-Instances)  
[[Swift] ARC의 정의 및 이해 - ARC의 기초 - 1탄](https://yudonlee.tistory.com/31)    
[[Swift] Strong Reference Cycle - ARC 기초 2탄](https://yudonlee.tistory.com/35)    
야곰 스위프트 프로그래밍