# Inheritance (상속)
스위프트의 클래스는 부모클래스로부터 물려받은 `메서드를 호출`할 수 있고,   
`프로퍼티에 접근`할 수 있으며, `서브스크립트도 사용`할 수 있습니다.   
또한, 부모클래스로부터 물려받은 `메서드, 프로퍼티, 서브스크립트 등`을 자신만의 내용으로   
재정의할 수도 있습니다.   
이때 자식클래스에서 재정의할 때 자식 클래스가 부모클래스의 요소들을 재정의한다는 것을 `명확하게` 확인시켜주어야 합니다.   

다른 클래스로부터 상속을 받지 않은 클래스를 `기반클래스(Base class)`라고 부릅니다.   

## 1️⃣ 클래스 상속
`상속`은 기반클래스를 다른 클래스에서 물려받는 것을 말합니다.   
```Swift
// 기반클래스 Person
class Person {
    var name: String = ""
    var age: Int = 0

    var introduction: String {
        return "이름 : \(name). 나이 : \(age)"
    }

    func speak() {
        print("가나다라마바사")
    }
}
```
위의 Person 클래스를 상속받은 Student 클래스
```Swift
class Student: Person {
    var grade: String = "F"

    func study() {
        print("Study hard...!!!")
    }
}
let jason: Student = Student()
jason.name = "jason"
jason.age = 10
jason.grade = "A"
print(jason.introduction)       // 이름: jason. 나이: 10
jason.speak()                   // 가나다라마바사
jason.study()                   // Study hard...!!!
```
위 예제에서 확인할 수 있듯이 Person 클래스를 상속받았기 때문에 부모 클래스가 물려준   
`프로퍼티와 메서드`를 사용할 수 있으며 자신이 정의한 프로퍼티와 메서드도 사용 가능합니다.

```Swift
// Student 클래스를 상속받은 UniversityStudent 클래스
class UniversityStudent: Student {
    var major: String = ""
}
let jenny: UniversityStudent = UniversityStudent()
jenny.major = "Art"
jenny.speak()
jenny.study()
```
- Person, Student, UniversityStudent 클래스의 상속 관계 모식도

<img src = "https://user-images.githubusercontent.com/92699723/209642527-19a4d484-90a3-4a78-a484-d4641ba34d80.png" width = "500" height = "400">

다른 클래스를 상속받으면 똑같은 기능을 구현하기 위하여 코드를 다시 작성할 필요가 없으므로   
`코드를 재사용하기 용이`하고 더불어 기능을 확장할 때 **기존 클래스를 변경하지 않고도 새로운 추가 기능을 구현한 클래스를 정의**할 수 있다.

> 물론 상속을 하지 못하도록 방지하는 키워드 `final`을 사용하면 모든 속성을 상속받지는 않습니다.

## 2️⃣ 재정의(Override)
자식클래스는 부모클래스로부터 물려받은 특성(인스턴스 메서드, 타입 메서드, 인스턴스 프로퍼티, 타입 프로퍼티, 서브스크립트 등)을   
그대로 사용하지 않고 자신만의 기능으로 변경하여 사용할 수 있습니다.   
이를 `재정의(Override)`라고 합니다.   

상속받은 `특성들을 재정의`하려면 새로운 정의 앞에 `Override`라는 키워드를 사용합니다.   
> Override 키워드는 스위프트 컴파일러가 조상클래스(부모를 포함한 상위 부모클래스)에   
> 해당 특성이 있는지 확인한 후 재정의하게 됩니다.   
> 만약 **조상클래스에 재정의할 해당 특성이 없는데 override 키워드를 사용하면 컴파일 오류가 발생합니다.**

### 📌 만약 자식클래스에서 부모클래스의 특성을 재정의했을때!
**부모클래스의 특성을 자식클래스에서 사용하고 싶다면** `super` 프로퍼티를 사용하면 됩니다.   
즉, **`자식클래스에서 특성을 재정의했지만 필요에 따라 부모클래스의 특성을 활용하고 싶을 때 super를 사용`** 합니다.   

## 2-1. 메서드 재정의
```Swift
class Person {
    var name: String = ""
    var age: Int = 0

    var introduction: String {
        return "이름 : \(name). 나이 : \(age)"
    }

    func speak() {
        print("가나다라마바사")
    }

    class func introduceClass() -> String {
        return "인류의 소원은 평화입니다."
    }
}

class Student: Person {
    var grade: String = "F"

    func study() {
        print("Study hard...!!!")
    }

    override func speak() {
        print("저는 학생입니다.")
    }
}

class UniversityStudent: Student {
    var major: String = ""

    class func introduceClass() {
        print(super.introduceClass())
    }

    override class func introduceClass() -> String {
        return "대학생의 소원은 A+입니다."
    }

    override func speak() {
        super.speak()
        print("대학생이죠.")
    }
}

// 각 인스턴스는 생성되었다고 가정하고 생략
yagom.speak()           // 가나다라마바사
jay.speak()             // 저는 학생입니다.
jenny.speak()           // 저는 학생입니다. 대학생이죠.

print(Person.introduceClass())      // 인류의 소원은 평화입니다.
print(Person.introduceClass())      // 인류의 소원은 평화입니다.
print(UniversityStudent.introduceClass() as String) // 대학생의 소원은 A+입니다.
UniversityStudent.introduceClass() as Void      // 인류의 소원은 평화입니다.
```
> UniversityStudent 클래스의 `introduceClass()`메서드에 override 키워드가 붙은 메서드와   
> 그렇지 않은 메서드 2가지가 있는 이유는 바로 **`반환 타입이 다르기 때문이다.`**
> as 뒤에 어떤 반환값을 쓰는지에 따라 다른 메서드로 취급하는지 알 수 있다.

## 3️⃣ 클래스의 이니셜라이저 - 상속과 재정의
값 타입의 이니셜라이저는 이니셜라이저 위임을 위해 이니셜라이저끼리 구분할 필요가 없었지만   
클래스에서는 `지정 이니셜라이저`와 `편의 이니셜라이저`로 역할을 구분합니다.   

### 🟢 3-1. 지정 이니셜라이저와 편의 이니셜라이저
- 지정 이니셜라이저(Designated Intializer)는 클래스의 주요 이니셜라이저입니다.
    **`이니셜라이저가 정의된 클래스의 모든 프로퍼티를 초기화해야 하는 임무를 갖고 있습니다.`**   
    클래스의 `기둥과 같은 역할`을 하므로 클래스에 `하나 이상 정의`합니다.   
    모든 클래스는 하나 이상의 지정 이니셜라이저를 갖습니다. (`다중 생성 가능`)

    > 만약 조상클래스에서 지정 이니셜라이저가 자손클래스의 지정 이니셜라이저 역할을 충분히 할 수 있으면,   
    자손클래스는 지정 이니셜라이저를 갖지 않을 수도 있습니다.   
    아마도 이런 경우는 조상클래스로부터 물려받은 프로퍼티를 제외하고 옵셔널 저장 프로퍼티 외에   
    다른 저장 프로퍼티가 없을 가능성이 큽니다.

- 편의 이니셜라이저(Convenience Intializer)는 `지정 이니셜라이저를 자신 내부에서 호출`합니다.   
  지정 이니셜라이저의 매개변수가 많아 외부에서 일일이 전달인자를 전달하기 어렵거나   
  특정 목적에 사용하기 위해서 편의 이니셜라이저를 설계할 수도 있습니다.   
  필수 요소는 아니지만, `클래스 설계자의 의도대로 외부에서 사용하길 원하거나`    
  `인스턴스 생성 코드를 작성하는 수고를 덜 떄 유용하게 사용`할 수 있습니다.   
    ```Swift
    init(매개변수들) {
        초기화 구문
    }

    convenience init(매개변수들) {
        초기화 구문
    }
    ```

### 🟢 3-2. 클래스의 초기화 위임
지정 이니셜라이저와 편의 이니셜라이저 사이의 관계를 간단히 정리해보면 3가지 규칙을 적용해볼 수 있습니다.   
> 1. `자식클래스의 지정 이니셜라이저는 부모클래스의 지정 이니셜라이저를 반드시 호출`해야 합니다.   
> 2. 편의 이니셜라이저는 `자신을 정의한 클래스`의 다른 이니셜라이저를 `반드시` 호출해야 합니다.   
> 3. 편의 이니셜라이저는 궁극적으로는 `지정 이니셜라이저를 반드시 호출`해야 합니다.

- 클래스의 초기화 위임 규칙 모식도
<img src="https://user-images.githubusercontent.com/92699723/209657128-eb687289-1575-41e2-b725-0837bf8d5a43.png" width=600 height=350>

- `편의 이니셜라이저 ②`는 `다른 편의 이니셜라이저 ①`를 호출하며 해당 편의 이니셜라이저는   
    궁극적으로 `지정 이니셜라이저 ⓐ`를 호출하게 됩니다.   
    -> **`규칙 2, 3을 만족`**   
    부모클래스는 자신보다 조상인 부모를 갖지 않으므로 규칙1은 해당사항 ❌
- `편의 이니셜라이저 ③`는 `지정 이니셜라이저 ⓒ`를 호출합니다.   
    편의 이니셜라이저는 자신의 클래스에 구현된 이니셜라이저만 호출할 수 있으므로   
    부모클래스의 이니셜라이저는 호출할 수 없습니다.   
    -> **`규칙 2, 3을 만족`**
    또한, `지정 이니셜라이저ⓑ, ⓒ` 모두 부모클래스의 `지정 이니셜라이저 ⓐ`를 호출하므로   
    -> **`규칙 1 만족`**

### 🟢 3-3. 2단계 초기화
스위프트의 클래스 초기화는 2단계를 거칩니다.   
1. **`1단계는 클래스에 정의한 각각의 저장 프로퍼티에 초깃값이 할당됩니다.`**   
    모든 저장 프로퍼티의 초기 상태가 결정되면 2단계로 돌입해 저장 프로퍼티들을 사용자 정의할 기회를 얻습니다.   
    그 후 비로소 새로운 인스턴스를 사용할 준비가 끝납니다.
2. 2단계 초기화는 **`프로퍼티를 초기화하기 전에 프로퍼티 값에 접근하는 것을 막아 초기화를 안전하게 할 수 있도록 해줍니다.`**   
    또, 다른 이니셜라이저가 프로퍼티의 값을 실수로 변경하는 것을 방지할 수도 있습니다.
---
스위프트의 컴파일러는 2단계 초기화를 오류 없이 처리하기 위해 아래의 4가지 안전확인을 실행합니다.   
1. 자식클래스의 지정 이니셜라이저가 **`부모클래스의 이니셜라이저를 호출하기 전에   
    자신의 프로퍼티를 모두 초기화했는지 확인`** 합니다.
    > 그래서 자식클래스의 지정 이니셜라이저에서 **`부모클래스의 이니셜라이저를 호출하기 전에   
    자신의 모든 (기본값이 없는) 저장 프로퍼티에 값을 할당`** 해주어야 합니다.
2. 자식클래스의 지정 이니셜라이저는 **`상속받은 프로퍼티에 값을 할당하기 전에   
   반드시 부모클래스의 이니셜라이저를 호출`** 해야 합니다.
3. `편의 이니셜라이저`는 자신의 클래스에 정의한 프로퍼티를 포함하여 **`그 어떤 프로퍼티라도 값을 할당하기 전에 다른 이니셜라이저를 호출`** 해야 합니다.
4. 초기화 1단계를 마치기 전까지는 이니셜라이저는 인스턴스 메서드를 호출할 수 없습니다.   
   또한, 인스턴스 프로퍼티의 값을 읽어들일수도 없습니다.   
   self 프로퍼티를 자신의 인스턴스를 나타내는 값으로 활용할 수도 없습니다.

#### 🅰️ 초기화 1단계
<img src = "https://user-images.githubusercontent.com/92699723/209659649-0ebe857e-d819-4fd8-bd86-bcf48a37ec92.png" width=500 height=300>

[ 1단계 ]
1. 클래스가 `지정 또는 편의 이니셜라이저를 호출`합니다.
2. 그 클래스의 `새로운 인스턴스를 위한 메모리가 할당`됩니다.   
   `메모리는 아직 초기화되지 않은 상태`입니다.
3. 지정 이니셜라이저는 클래스에 정의된 `모든 저장 프로퍼티에 값이 있는지 확인`합니다.   
   현재 클래스 부분까지의 저장 프로퍼티를 위한 `메모리는 이제 초기화`되었습니다.
4. 지정 이니셜라이저는 부모클래스의 이니셜라이저가 같은 동작을 행할 수 있도록 `초기화를 양도`합니다.   
5. 부모클래스는 상속 체인을 따라 `최상위 클래스에 도달할 때까지 이 작업을 반복`합니다.

<img src = "https://user-images.githubusercontent.com/92699723/209661120-dd8dd71c-9791-4585-ace7-4d9f1a2e4062.png" width=500 height=300>

[ 2단계 ]   
1. 최상위 클래스로부터 최하위 클래스까지 `상속 체인을 따라 내려오면서 지정 이니셜라이저들이 인스턴스를 제 각각 사용자 정의`하게 됩니다.   
   이 단계에서는 `self를 통해 프로퍼티 값을 수정`할 수 있고, `인스턴스 메서드를 호출`하는 등의 작업을 진행할 수 있습니다.
2. 마지막으로 `각각의 편의 이니셜라이저를 통해 self를 통한 사용자 정의 작업을 진행`할 수 있습니다.

```Swift
class Person {
    var name: String
    var age: Int

    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
}

class Student: Person {
    var major: String

    init(name: String, age: Int, major: String) {
        self.major = "Swift"
        super.init(name: name, age: age)
    }

    convenience init(name: String) {
        self.init(name: name, age: 7, major: "")
    }
}
```
- Student 클래스의 지정 이니셜라이저 `init(name: age: major)`는   
  부모클래스의 지정 이니셜라이저를 호출하기 전에 자신의 Self 프로퍼티를 이용해 `major 프로퍼티`의 값을 할당합니다.   
  -> **안전확인 중 1번의 조건을 만족**
- `super.init(name: name, age: age)`를 통해 부모클래스의 이니셜라이저를 호출했으며   
  그 외에 상속받은 프로퍼티가 없으므로 부모의 이니셜라이저 호출 이후에 값을 할당해줄 프로퍼티가 없습니다.   
  -> **2번 조건 만족**
- `convenience init(name:)`은 따로 차후에 값을 할당할 프로퍼티가 없고,   
  다른 이니셜라이저를 호출했다.   
  -> **3번 조건 만족** 
- 이니셜라이저 어디에서도 인스턴스 메서드를 호출하거나 인스턴스 프로퍼티의 값을 읽어오지 않았다.   
  -> **4번 조건 만족**

## 4️⃣ 요구 이니셜라이저
`required`수식어를 클래스의 이니셜라이저 앞에 명시해주면 이 클래스를 `상속받은 자식클래스에서 반드시 해당 이니셜라이저를 구현`해주어야 합니다.   
다시 말해 **`상속받을 때 반드시 재정의해야 하는`** 이니셜라이저 앞에 required 수식어를 붙여줍니다.
다만, 자식클래스에서 요구 이니셜라이저를 재정의할 때는 override 수식어 대신에 required 수식어를 사용합니다.   
```Swift
class Person {
    var name: String

    // 요구 이니셜라이저 정의
    required init() {
        self.name = "Unknown"
    }
}

class Student: Person {
    var major: String = "Unknown"
}
let jason: Student = Student()
```
Student 클래스의 `major 프로퍼티에 기본값이 있으며` 별다른 지정 이니셜라이저가 없기 때문에   
이니셜라이저가 자동으로 상속된 것이다.
